# 유용한 팁들

## var와 let의 차이

```js
for (var i = 0; i < tab_num; i++) {
  button[i].addEventListener("click", function () {
    for (var j = 0; j < tab_num; j++) {
      button[j].classList.remove("orange");
    }
    button[i].classList.add("orange");
    for (var k = 0; k < tab_num; k++) {
      content[k].classList.remove("show");
    }
    content[i].classList.add("show");
  });
}
```

탭 기능을 만들어보다가 for문에서 var를 사용하면 작동을 하지 않았다.  
let을 쓰면 잘 작동했는데  
var와 let의 변수 범위 차이인 것을 알 수 있었다.

이벤트리스너는 클릭시 실행되는 코드인데  
var를 사용하면 전역변수로 사용된다.  
여기서 변수 `i`는 반복문이 끝나면 `0`으로 돌아가지않고  
`3`이 남아있게된다. 그래서 에러가 발생한다.

let을 사용하면 for문 안쪽으로 반복문을 돌고 다시 `0`으로 돌아가기 때문에  
let을 사용해야 한다.

var가 만능인줄 알았는데, 범위가 중요하다는 것을 알게 되었다.

```js
for (let i = 0; i < tab_num; i++) {
  button[i].addEventListener("click", function () {
    for (let j = 0; j < tab_num; j++) {
      button[j].classList.remove("orange");
    }
    button[i].classList.add("orange");
    for (let k = 0; k < tab_num; k++) {
      content[k].classList.remove("show");
    }
    content[i].classList.add("show");
  });
}
```

# Node.js

## non-blocking.io

일반적인 서버는 요청을 오는 순서대로 차례대로 처리하지만, nodejs는 모든 요청을 받고  
빨리 처리할 수 있는 것부터 결과를 낸다.

수학적 연산을 요구하지 않는 채팅서비스나 SNS에 Nodejs를 많이 사용한다.

스타트업, 프로토타입 만들기에도 많이 사용

- 초보자에게 쉽고
- 템플릿으로 간편하게
- 갑자기 사용자가 늘어도 감당가능
- 자바스크립트 문법만으로 프론트, 백엔드 공부가능

단점으로 보안 취약, 처리속도 떨어짐, 수학적연산이나 이미지처리같은 라이브러리 부족,  
non-blocking 처리방식은 다른 언어에서도 비슷하게 구현 가능.

## form 데이터를 서버로 전송해보자

### 태그 셋팅

HTML의 form 내의 input들에 입력한 데이터들을 서버로 전송할 수 있습니다.  
전송하고 싶다면 여러분이 form 태그에 여러가지 전송 방법들을 명시해주시면 되겠습니다.

```js
<form action="/add" method="POST">
  <div class="form-group">
    <label>오늘의 할일</label>
    <input type="text" class="form-control" name="title">
  </div>
  <div class="form-group">
    <label>날짜</label>
    <input type="text" class="form-control" name="date">
  </div>
  <button type="submit" class="btn btn-outline-secondary">Submit</button>
</form>
```

폼 전송버튼을 누를 시 `/add` 라는 경로로 `POST` 요청을 하는 폼이 완성되었습니다.  
form 태그의 method 속성은 `GET`/`POST` 중 어떤 요청을 할 건지 정해주는 부분,  
`action`은 어떤 경로로 요청할건지를 정해주는 부분입니다.  
알아서 잘 채워넣으시면 이제 전송버튼을 누를 때마다 서버에 input에 담긴 데이터들을 전송하게 됩니다.  
화룡점정으로 input마다 name 속성을 이용해 각각의 input에 이름을 써주었습니다.  
폼 전송할 때 input에 이름이 없으면 서버에서 이게 어떤 input에 적혔던 데이터인지 알 수 없으니깐요!

### body-parser 설치

1번까지만 해도 데이터가 잘 전송되긴 하는데, body-parser라는 라이브러리가 있어야  
보낸 데이터들 처리가 쉽게 가능합니다.  
2021년 이후로는 body-parser 라이브러리가 express에 기본 포함되어있어  
따로 npm으로 설치할 필요가 없습니다.  
server.js에서 위쪽에 다음 코드를 추가합니다.

```js
app.use(bodyParser.urlencoded({ extended: true }));
```

body-parser 설치 끝입니다.

### POST 요청 처리하는 코드 짜기

app.get 하던 것과 매우 비슷하게 post 요청을 처리.  
이렇게 하면 끝입니다.

```js
app.post("/add", function (요청, 응답) {
  console.log(요청.body);
  응답.send("전송완료");
});
```

그럼 누군가가 `/add` 경로로 `post` 요청을 할 때  
터미널 콘솔창에 `요청.body`를 출력해볼 수 있습니다.  
`요청.body`는 폼에 입력한 제목과 날짜 데이터가 들어가있을 것입니다.  
(그리고 응답.send() 라는 함수로 성공했다는 메세지를 브라우저에 전달가능합니다.)  
이것으로 폼에서 서버로 데이터보내기 끝입니다.

## REST API 원칙

1. Uniform interface  
   인터페이스는 일관성이 있어야한다.

   - 하나의 URL로는 하나의 데이터를 가져와야함
   - 간결하고 예측가능하게
   - URL 이름짓기 관습을 따르자

2. Client-server 역할 구분하기
   클라이언트에게 서버역할을 맡기거나  
   클라이언트에서 DB에 있는 자료를 직접 꺼내는식으로 코드를 작성하지말자.

3. Stateless
   요청들은 각각 독립적으로 처리.  
   요청1과 요청2가 의존성이 존재하도록 작성하지말자.  
   요청하나만으로 자료를 가져오기 충분하도록 작성.

4. Cacheable
   요청을 통해 보내는 자료들은 캐싱이 가능해야함.  
   캐싱이 가능하다고 표시하거나 캐싱 기간 설정.  
   (주로 브라우저에서 알아서 처리함)

## URL 이름짓기 관습

```
instagram.com/explore/tags/kpop
instagram.com/explore/tags/food
facebook.com/natgeo/photos
facebook.com/bbc/photos
```

이 URL들은 페이스북이 매우 잘 만든 API입니다.  
`facebook.com/bbc/photos` 무엇을 지칭하는지 한눈에 들어온다.

- 단어들을 동사보다는 명사 위주로 구성함

- 응용해서 다른 정보들을 쉽게 가져올 수 있을 정도로 일관성 있음

- 대충 봐도 어떤 정보가 들어올지 예측이 가능함

이외에도 이름을 잘 지을 수 있는 방법은

- 띄어쓰기는 언더바\_대신 대시-기호-사용

- 파일 확장자 쓰지 말기 (.html 이런거)

- 하위 문서들을 뜻할 땐 / 기호를 사용함 (하위폴더같은 느낌)

여러가지가 있습니다. 이것만 잘 지켜주시면 예쁜 서버 API들이 완성됩니다.

## MongoDB 비밀번호 가리기

Nodejs + MongoDB를 사용하는 강의를 듣던 중 MongoDB를 server.js에 연결해보는 시간이었다.

```js
const MongoClient = require("mongodb").MongoClient;
MongoClient.connect(
  "mongodb+srv://Zamoca:<password>@cluster0.ds7ie.mongodb.net/myFirstDatabase?retryWrites=true&w=majority",
  function (error, client) {
    //listen(서버를 오픈할 포트번호, function(){서버 오픈시 실행할 코드})
    app.listen(8080, function () {
      console.log("listening on 8080");
    });
  }
);
```

`<password>` 부분에 비밀번호를 입력하고 따라만하면 되는 거였지만 중요한 문제는 내가 작성하는 파일들은 깃허브에 올리는 중이라는 것이다.  
비밀번호 때문에 server.js를 repo에서 지울 수는 없고, 보안은 걱정되던 와중에 검색해서 해결방법을 찾아보기로 하였다.

https://poiemaweb.com/nodejs-keeping-secrets

이 링크를 발견하게 되었다!  
여러 가지 해결방법이 있었는데

1. 코드 내에 하드 코딩하기

2. 설정파일 사용하기

3. 환경변수 사용하기

4. command-line에서 argument 요구하기

5. js파일 만들어서 import하기

등이 있었다.

이 중에서 2번인 json파일로 설정파일을 만들어서 넣어주는게 간단해보여서 시도해보았다.  
링크에서 예시는 mysql을 이용한 예시였지만, 나는 mongoDB였기 때문에 콜백함수 이전 인수만  
백틱(`)을 사용하여 바꿔주었다.

```js
onst db_config = require('./db_config.json');

const MongoClient = require('mongodb').MongoClient;
MongoClient.connect(db_config.database, function(error, client){
    //listen(서버를 오픈할 포트번호, function(){서버 오픈시 실행할 코드})
    app.listen(8080, function() {
        console.log('listening on 8080')
    });
})
```

솔직히 될 줄은 몰랐는데 코드를 넣고 서버를 돌려보니 잘돌아간다... 신기하다.  
작성한 json파일은 .gitignore에 추가해 깃헙에 올라가지 않게 설정해줬다.  

## NoSQL 데이터베이스

SQL문없이도 사용할 수 있는 데이터베이스.
MySQL처럼 테이블에 국한되지 않고 자유로운 형식으로 데이터를 쉽게 분산저장할 수 있다.

### 종류

- Key-value 모델 : Object, JSON 자료형 형식으로 데이터를 쉽게쉽게 저장, 출력이 가능합니다. 가장 심플함

- Document 모델 : 테이블 대신 Collection이라는 문서 기반으로 데이터를 분류하고 저장합니다. 테이블보다는 훨씬 유연합니다. 

- Graph 모델 : 데이터를 노드의 형태로 저장하고 노드간의 흐름 또는 관계를 저장할 수 있습니다. 

- Wide-column 모델 : 한 행마다 각각 다른 수, 다른 종류의 열을 가질 수 있습니다. (스키마가 자유로움) 

우리가 사용하고 있는 MongoDB도 Key-value, Document 모델 저장방식을 차용하고 있습니다.

### 특징

1. Scaling이 쉽다는 장점이 있습니다.  

찰나의 순간에 대량의 데이터를 저장해야한다면 어떻게할까요?  
기존 올드한 관계형 데이터베이스는 확장이 매우 어렵습니다. 보통 scale up 이라는 방법으로 서버의 성능을 키워야합니다.  
하지만 대부분의 NoSQL 데이터베이스는 scale out이라는 방법으로 데이터를 분산저장하는 걸 기본적으로 지원합니다.  
확정 걱정할 필요없이 쉽게 쉽게 데이터 입출력에만 신경쓸 수 있는 것이죠.  
그래서 대량의 데이터를 빠르게 입출력해야한다면 NoSQL이 제격입니다.  

2. 대부분 다루기가 쉽습니다.   

SQL 이라는 언어를 새로 배우지 않아도 데이터를 쉽게 입출력할 수 있습니다.   
자바스크립트 object{} 자료형 다루듯이 데이터를 입출력할 수 있으니 사용자에게 매우 편리하죠.   
그리고 여러분이 서버에서 쓰던 프로그래밍 언어로 DB를 다룰 수 있다는 장점이 있습니다. MongoDB도 그러고 있죠?  

3. 대부분 스키마 정의 없이도 쉽게 쓸 수 있습니다.

장점이자 단점일 수 있습니다. 그래서 MongoDB에선 스키마를 미리 정의하기 위한 Mongoose같은 라이브러리를 추가해서 사용하기도 합니다.  

4.  NoSQL 데이터베이스는 기본적으로 SQL에서의 JOIN 연산을 적용하는게 기본적으로 어렵습니다.   

서버 단에서 JOIN 연산을 쉽게 처리해주는 라이브러리를 이용합니다.  

# express.js  

## 세션,JWT,OAuth 등 회원인증 방법론 쉽게 이해하기  

### Session-based  

사용자의 세션정보를 저장해서 로그인 기능을 구현하는 방법입니다.  

- 이 사람이 로그인 했었다는 정보를 서버의 메모리에다가 기록해놓습니다. (세션을 저장합니다)

- 그리고 고객이 로그인이 필요한 페이지(Mypage 등)를 요청을 하면  

- 세션을 들춰봐서 이 사람이 로그인했다는 정보가 나오면 통과

좀 더 자세히 보면

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 

이 사람이 언제 어디서 로그인 했는지 이런 정보를 담은 자료 하나를 만들어서 저장합니다. 

"Kim 이라는 사람이 7시에 로그인했습니다."  

이런 정보를 서버 메모리에 저장해둡니다.  

2. 그리고 로그인한 유저마다 각각 유니크한 세션아이디라는걸 발급합니다.  

당연히 로그인한 사람이 여러명일 수 있으니 유니크한 세션아이디를 발급해서 구분지어주는게 좋겠죠.   

그래서 abc123 이라고 세션아이디를 하나 예쁘게 발급해줬습니다.  

3. 발급한 세션아이디는 쿠키에 담아서 고객 브라우저에 전송해줍니다.  

세션아이디는 고객과 서버 둘다 보관합니다. 그래서 쿠키에 담아서 고객에게 보내줍니다.  

클라이언트에서 로그인이 필요한 페이지를 요청한 경우,  

이 사람이 적법하게 로그인 했던 사람인지 검사해보도록 합시다.  

1. 고객이 로그인합니다. 

아이디 / 비번을 서버로 전송하면 

서버는 기존에 있던 DB에 아이디/비번 세트가 존재하면 옳다구나 하고 세션아이디를 만들어줍니다. 

그리고 세션아이디들을 담을 변수나 뭐 DB 공간을 마련해서 거기 저장해둡니다. 그걸 세션데이터라고 부릅시다. 

(저장은 DB에 할 수도 있고 서버 메모리(그냥 변수)에 저장할 수 있습니다. )

그리고 세션 아이디를 쿠키라는 것에 이쁘게 포장해서 고객의 브라우저에 쿠키를 강제로 저장시킵니다. 

 

2. 고객이 마이페이지를 요청합니다. 

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 심플합니다. 

3. 쿠키에 세션아이디가 포함되어있는지 검사합니다.  

원래 고객이 페이지를 요청할 때 마다 자동으로 쿠키가 서버로 전송됩니다.  

그럼 서버는 쿠키에 기록된 세션아이디를 서버메모리 or DB에 저장되어있던 세션아이디와 비교해서  

있으면 통과시켜줍니다.   


4. 서버는 마이페이지를 보내줍니다. 

그 전에 이 회원의 이름, 나이, 성별 등의 DB 정보가 필요하다면  

세션데이터를 참고해서 이 사람의 이름, 나이 등의 정보를 DB에서 꺼내옵니다.   

 
### Json Web Token(JWT)  

토큰 방식은 세션데이터를 서버에 저장하지 않고  

마이페이지를 열람할 수 있는 열쇠(토큰)를 사용자에게 쥐어주는 것입니다.   

그래서 그 열쇠에는 session방식보다 약간 더 많은 정보들이 들어갑니다.   

요즘 토큰토큰 거리면 JSON Web Token을 말하는 것인데, 아무튼 어떤 방식인지 자세히 알아보도록 합시다.   

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면  

서버는 옳다구나 하고 Token 하나를 만들어서 고객 브라우저로 보내줍니다.  

Token은 그냥 긴 암호화된 문자열일 뿐이고, 사용자가 로그인 했었는지, 아이디는 무엇인지 이런 정보들을 넣을 수 있습니다.  

물론 위조가 불가능하도록 특별한 서명이 추가됩니다.   

토큰은 쿠키나 로컬스토리지라는 곳에 저장됩니다.  

(+ 코드를 잘 짜서 고객이 페이지 방문시마다 Token이 서버로 보내지도록 미리 장치를 추가합니다)  


2. 고객이 마이페이지를 요청하면   

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다.   

"님 로그인 했었음?" 이라고 물어봐야하니까요.  

물어보는 과정은 그냥 토큰 검사입니다.   

3. 서버는 토큰을 검사합니다  

고객이 마이페이지 요청시 함께 보낸 Token이 적법한지 검사합니다.   

유통기한이 지나지 않았는지, 서명이 잘 되어있는지, 블랙리스트에 등록된 토큰인지 이런 검사를 거친 후   

이상이 없으면 마이페이지로 통과시켜줍니다.   

서버는 세션데이터 등을 메모리/DB에 저장해둘 필요가 없으니 나중에 서버 스케일링시 큰 문제가 없다는 장점도 있습니다. 
 
하지만 단점이나 보안상 취약점이 존재할 수 있습니다.  

이 사람이 로그인 했는지에 대한 정보 전체를 서버는 가지고 있지 않고 사용자가 가지고 있게 하는 것 자체가 보안상 좋은 방법은 아닙니다.  

JWT 정보를 다른 사람이 훔치면 어쩔 것임? 이제 훔친 사람은 자유롭게 로그인이 가능하겠는데요?   

그래서 stateful JWT 라고 부르는 '어떤 사람이 언제 로그인했는지'를 서버에 저장해두는 방식이 좋은 관습이긴 한데  

그 중 하나가 refresh token 이런 방식입니다.    

그러면 위에서 말했던 세션 방식이랑 기능 상 다를바가 없습니다.   

### Open Authentication(OAuth)

이 방법은 쉽게말하면 페이스북, 구글 로그인입니다.

다른 사이트의 계정정보를 불러와서 가입을 승인시키고 로그인하는 방식입니다.  

1. 어떤 사람이 '페이스북으로 로그인' 버튼을 눌렀다고 칩시다.  

그럼 페이스북 팝업이 뜹니다.   

"코딩애플 앱에 본인의 페이스북 이름, 아이디 제공을 승인하시겠습니까?"  

승인을 눌러봅니다.  

2. 그럼 페이스북은 우리 server.js에게 이 유저의 이름, 아이디 정보를 보내줍니다.  

3. 이 사람 페이스북 정보를 바탕으로 세션이나 토큰을 만들어줍니다.  

DB에 이름, 아이디를 저장해서 회원 목록을 하나 만들어주든가,  

그와 동시에 세션 데이터를 만들어주든가 하시면 됩니다.  
 
4. 고객이 마이페이지를 요청하면   

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다.   

"님 로그인 했었음?" 이라고 물어봐야하니까요.  

5. 서버는 토큰이나 세션을 검사합니다  

위에서 세션을 만들어 줬다면 세션이 있는지 검사하면 되고,  

위에서 토큰을 만들어 줬다면 토큰이 적법한지 검사하면 되겠죠?  

통과되면 마이페이지를 응답.render() 해줍니다.  

비밀번호를 취급안해도 된다는 장점 때문에 관리도 편리하고 유저도 편리함을 느낍니다. 

페이스북 등에서 제공하는 공식 개발문서가 많기 때문에 따라하기만 하면 일사천리로 개발이 가능합니다. 

하지만 단점은 구글이나 페이스북이 1. OAuth를 중단하거나 2. 방법을 수정하거나 3. 페이스북 API 서버 다운으로 접속이 불가능하다면

우리 사이트 로그인도 불가능합니다. 

### 회원 기능이 있다면

- 로그인 했을 때만 글쓰기 가능
- 누가 글 발행했는지 글쓴이 저장
- 내 글만 모아보기