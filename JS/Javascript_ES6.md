# this 키워드

1. 그냥 쓰거나 일반 함수 안에서 쓰면 window 객체를 가리킴

```js
console.log(this); //출력 : {Window}
```

2. 오브젝트 내 함수안에서 쓰면 그 함수를 가지고 있는 오브젝트를 뜻함

```js
var 오브젝트 = {
  data: "Kim",
  함수: function () {
    console.log(this);
  },
};

오브젝트.함수(); // 출력 : {data: "Kim", 함수 : f}
```

1,2번째는 같은 이야기입니다.  
자바스크립트는 항상 window오브젝트를 상위로 가지고있기때문에 window는 생략되어있습니다.  
그래서 1번에서 가리키는 this의 오브젝트는 window가 됩니다.

3. 오브젝트 생성기계 안에서 쓰면 새로 생성되는 오브젝트를 뜻함

```js
function 기계() {
  // constrctor
  this.이름 = "Kim"; // instance
}
```

자바 스크립트에서 오브젝트를 여러개 만들고 싶은 경우  
오브젝트를 복사하는게 아니라 constructor라는걸 만들어서 사용합니다.  
constructor는 오브젝트를 복사해서 생성해주는 기계입니다.  
여기서 `this.이름`은 기계로부터 새로 생설될 오브젝트를 의미합니다.

```js
function 기계() {
  this.이름 = "Kim";
}
var 오브젝트 = new 기계();
```

이렇게 new키워드를 이용하면 새로운 오브젝트를 꺼낼 수 있습니다.

4. 이벤트리스너내에서 사용하면 this는 e.currentTarget을 의미

```js
document.getElementById("버튼").addEventListener("click", function (e) {
  console.log(this);
});
```

여기서 this를 입력하면 e.currnetTarget라는 의미입니다.  
e.currentTarget은 지금 이벤트가 동작하는 곳을 뜻합니다.

```js
<button id="버튼">버튼</button>
```

위에서 `getElementById('버튼')`을 입력했으니 현재의 e.currentTarget은 html의 버튼을 의미합니다.

# Arrow function 문법

함수 본연의 기능으로는

1. 코드들을 기능으로 묶을 때 사용
2. 입출력 기계를 만들고 싶을 때 사용

여기서 Arrow Function은 함수 본연의 입출력기능을 직관적으로 표현해줍니다.

```js
function 더해주세요(x) {
  return x + 2;
}
```

이렇게 일반 함수로 입출력 기능을 표현할 수 있지만

```js
var 두배만들기 = (x) => {
  return x * 2;
};
```

Arrow Function은 직관적으로 표현가능합니다.

또한 파라미터가 하나라면 소괄호를 생략 가능합니다

```js
var 두배만들기 = (x) => {
  return x * 2;
};
```

여기서 중괄호 안에 코드가 한줄이라면 중괄호도 생략가능하고 return도 생략 가능합니다.

```js
var 두배만들기 = (x) => x * 2;
```

추가로 arrow function을 쓰면 내부에서 this값을 쓸 때 밖에 있던 this값을 그대로 사용합니다.

일반 함수에서의 this는 오브젝트 내 함수안에서 쓰면 그 함수를 가지고 있는 오브젝트를 뜻한다고 했었습니다.

```js
var 오브젝트1 = {
  함수: function () {
    console.log(this);
  },
};

오브젝트1.함수();
```

여기서는 오브젝트1이 콘솔창에 출력됩니다.

Arrow Function에서 this는 외부에 있는 this를 가져옵니다

```js
var 오브젝트1 = {
  함수: () => {
    console.log(this);
  },
};

오브젝트1.함수();
```

여기서 오브젝트1 위의 코드에서 this가 없으므로 window오브젝트를 출력합니다.  
Arrow Function을 사용하는 것이 항상 장점은 아닙니다.  
내가 예측하던 this값과 달라질 수도 있으니 단점이 될 수 있습니다.  
this의 뜻이 달라지는 것 처럼 일반 function과 용도가 완전 같지 않기 때문에  
일반 function을 항상 대체할 수 있는 문법이 아닙니다. 그것만 주의합시다.

# 변수의 Hoisting 현상

자바스크립트는 변수나 함수를 선언하면 Hoisting이라는 현상이 일어납니다.  
자바스크립트는 변수나 함수의 선언부분을 변수의 범위 맨 위로 강제로 끌고가서 가장 먼저 해석합니다.  
그게 Hoisting입니다.

예를 들어봅시다.

```js
function 함수() {
  console.log("hello");
  var 이름 = "Kim";
}
```

이렇게 함수 내에서 변수를 만들었다고 칩시다.  
근데 자바스크립트가 이 코드를 해석하는 순서는 이렇게 됩니다.

```js
function 함수() {
  var 이름;
  console.log("hello");
  이름 = "Kim";
}
```

변수의 선언 부분을 강제로 변수의 범위 맨 위로 끌고가서 해석하고 지나갑니다.  
우리 눈에 보이진 않지만 자바스크립트는 코드 동작 순서가 이렇습니다.  
암튼 이게 Hoisting 현상입니다.  
함수를 만들어도 똑같고, 변수를 let, const로 만들어도 똑같습니다.

# 문자를 다루는 Template literals

기존 자바스크립트에서는 문자열을 다룰 때 따옴표를 주로 사용했었습니다.  
ES6에서는 따옴표 대신 backquote혹은 backtick(`)이라는 기호를 사용해서 문자를 만드는데  
여러 장점이 있습니다.

1. 문자 중간 엔터키 입력이 가능합니다.

자바스크립트 문자열은 문자 중간에 엔터키치시면 안됩니다.  
하지만 백틱으로 문자를 만드시면 엔터키가 자유롭게 가능합니다.

```js
var 문자 = `안녕  
하세요`;
```

2. 문자 중간에 변수를 집어넣을 때 편리합니다.

자바스크립트 문자열은 문자 중간에 변수를 넣고 싶은 경우 문자를 쪼개서 + 기호로 넣어야합니다.  
하지만 백틱으로 문자를 만드시면 문자 중간에 ${변수명} 이렇게 쉽게 넣을 수 있습니다.

```js
var 이름 = "손흥민";
var 문자 = `안녕하세요 ${이름} 입니다`;
```

그래서 자바스크립트 문자로 HTML을 작성할 때도 유용합니다.

```js
var 문자 = `
<div>
  <div>
    ${변수명}
  </div>
</div>`;
```

## tagged literal

ES6는 tagged literals라고 해서 함수로 문자 해체분석기능을 만들어줄 수도 있습니다.  
문자 중간중간에 있는 단어 순서를 바꾸거나 변수를 제거하거나 할 때 유용합니다.

```js
var 변수 = "손흥민";

function 해체분석기() {
  return 10;
}

해체분석기`안녕하세요 ${변수} 입니다`;
```

맨 마지막줄에서 함수를 실행시킬 때 소괄호가 아니라 문자를 이용해서 함수를 실행시킬 수 있습니다.  
실행할 함수이름을 쓰시고 소괄호 대신 `백틱` 문자를 붙여주시면 됩니다.  
그럼 함수가 실행됩니다. 위의 예제코드에선 해체분석기()라는 함수가 실행되고 있습니다.

왜 이렇게 사용하냐면  
함수뒤에 `문자`를 붙여 실행하면 그 `문자열`을 해체분석할 수 있기 때문입니다.  
해체분석용 함수를 한번 만들어봅시다.

```js
var 변수 = "손흥민";

function 해체분석기(문자들, 변수들) {
  console.log(문자들);
  console.log(변수들);
}

해체분석기`안녕하세요 ${변수} 입니다`;
```

함수의 파라미터 두개를 추가해줍니다.  
이제 이 함수는 막줄처럼 `문자열`을 이용해서 실행시키면 그 `문자열` 해체분석역할을 할 수 있습니다.  
첫째 파라미터 문자들은 `백틱` 내의 순수 문자만 골라서 Array로 만들어놓은 파라미터이고,  
둘째 파라미터 변수들은 `백틱` 내의 ${} 변수를 담는 파라미터입니다.  
(백틱 내에 변수가 2개 3개다 그러면 파라미터를 뒤에 더 추가해주시면 됩니다)  
이제 이 파라미터들로 `문자열`을 재조합하거나 분석할 수 있습니다.

```js
var 변수 = "손흥민";

function 해체분석기(문자들, 변수들) {
  console.log(문자들[1] + 변수들);
}

해체분석기`안녕하세요 ${변수} 입니다`;
```

그럼 이 코드는 실행하면 콘솔창에 뭐가 출력될까요?  
문자들을 모아놓은 Array중 1번째 문자 + 변수를 출력해줄 겁니다.  
그래서 '입니다손흥민' 이라는 문자가 출력됩니다.  
이렇게 ``백틱 내의 문자들을 해체해서 내 맘대로 다시 나열할 수 있게 도와주는 함수를 제작한 것입니다.

# Spread Operator(...)

마침표를 연달아서 3개... 찍으시면 그게 spread operator라는 문법입니다.  
한글로는 펼침연산자이렇게 번역가능한데  
무슨 역할을 하냐면
"괄호제거 해주는 연산자" 입니다.  
Array에 붙여보도록 합시다.

```js
var 어레이 = ["hello", "world"];
console.log(어레이);
console.log(...어레이);
```

그럼 어레이라는 array에 붙어있던 괄호를 제거해줍니다.  
3번줄처럼 spread operator를 붙여서 출력해보시면  
괄호가 제거된 'hello', 'world'만 콘솔창에 출력됩니다.  
이게 spread operator의 기능입니다.

그렇다면 array 두개를 합치고 싶으면 어떻게 할까요?

```js
var a = [1,2,3];
var b = [4,5];
var c = [여기엔 1,2,3,4,5 가 들어오게 만들려면?];
```

spread operator를 사용하시면 매우 쉽습니다.

```js
var a = [1, 2, 3];
var b = [4, 5];
var c = [...a, ...b];
```

이렇게 한 뒤에 c라는 어레이를 출력해보면 `[1,2,3,4,5]`가 되어있습니다.  
`...` 연산자를 이용해서 괄호를 없앤 a와 b를 집어넣는다는 소리입니다.  
어레이 합치기 완성입니다.

그럼 어레이 복사의 경우도 알아봅시다.

```js
var a = [1, 2, 3];
var b = a;

console.log(a);
console.log(b);
```

등호 `=` 를 이용하시면 쉽게 a에 있던 값을 b에 집어넣을 수 있습니다.  
그런데 자바스크립트에선 복사를 이렇게 하시면 큰일납니다.  
등호로 복사를 하시면 a와 b 변수는 `[1,2,3]`을 각각 따로 하나씩 가진게 아니라
`값 공유`가 일어납니다.  
그래서 a라는 array를 수정하면 b도 똑같이 바뀌는 신기한 버그가 일어납니다.

(나중에 자료형배울 때 다룰 것이지만 왜 그러냐면 등호쓰시면 값을 복사한게 아니라 `[1,2,3]` 값이 저기있어요~ 라고 가리키는 화살표를 복사하신 것입니다.)

그래서 값을 공유하지 않고 각각 독립적인 값을 저장하도록  
array를 복사하시려면 옛날엔 이상한 방법을 많이 썼는데  
요즘은 spread를 이용하시면 되겠습니다.

```js
var a = [1, 2, 3];
var b = [...a];

console.log(a);
console.log(b);
```

spread를 이용해서 a값의 괄호를 제거해준 다음에 다시 괄호를 씌우는 겁니다.  
그렇게 하시면 아까처럼 a와 b 변수의 값 공유가 일어나지 않습니다.

spread operator로 object 합치기/복사도 할 수 있습니다.

```js
var o1 = { a : 1, b : 2 };
var o2 = { c : 3, 그리고 o1에 있는거 전부.. }
```

o2를 만들고 싶은데 o1에 있던 내용들을 그대로 가져다가 추가하고 싶습니다.  
그럼 어떻게 해야되냐면 고민하지말고 spread operator를 떠올리시면 됩니다.  
이 연산자는 대괄호 뿐만아니라 중괄호도 제거해줍니다.  
그래서 이렇게 쓰시면

```js
var o1 = { a: 1, b: 2 };
var o2 = { c: 3, ...o1 };
console.log(o2);
```

o2라는 오브젝트를 출력해보면 a, b, c키값이 다 들어있습니다.  
왜냐면 o1오브젝트를 spread 연산자를 이용해 괄호를 벗겨서 추가했기 때문입니다.  
오브젝트 shallow copy도 비슷한 방식으로 합니다.  
(강의에선 deep copy라고 한거같은데 deep copy는 오브젝트 안의 오브젝트까지도 엮임현상없이 카피하는걸 뜻합니다. shallow는 그냥 맨 위의 오브젝트하나만 카피하는걸 뜻합니다)

오브젝트의 key값 중복이 발생하면 어떻게될까요?

```js
var o1 = { a: 1, b: 2 };
var o2 = { a: 3, ...o1 };
console.log(o2);
```

o2를 o1항목을 추가해서 만들고 싶은데 a라는 키값이 이미 있는겁니다.  
이렇게 a라는 값이 중복이 발생하면 무조건 뒤에 오는 a가 이깁니다.  
그래서 출력해보면 a : 1 이라는 자료가 담겨져있습니다.

Spread operator 나머지 활용방법을 알아봅시다.

array를 파라미터 형태로 집어넣을 때 씁니다.

일단 예시를 들기 위해 함수를 하나 만들어봅시다.

```js
function 더하기(a, b, c) {
  console.log(a + b + c);
}
더하기(1, 2, 3);
```

파라미터를 3개 받아와서 전부 더해주는 더하기라는 함수를 만들어봤습니다.  
그런데 여기 파라미터를 집어넣을 때  
직접 1,2,3이라고 작성해서 넣는게 아니라  
이미 존재하는 array에 있던 내부 자료들을 쏙 집어넣고 싶으면 어떻게하나요?  
그니까 예를 들면...

```js
function 더하기(a, b, c) {
  console.log(a + b + c);
}
```

```js
var 어레이 = [10, 20, 30];
```

어레이라는 자료 안에 있는 모든 숫자 10,20,30을 더하기() 함수의 파라미터로 집어넣으려면 어떻게 해야합니까.

```js
더하기(10, 20, 30);
```

이렇게 직접 손으로 적거나

```js
더하기(어레이[0], 어레이[1], 어레이[2]);
```

이렇게 하거나 해야겠죠?
근데 그게 귀찮으시면 spread 연산자를 쓰시면 됩니다.

```js
function 더하기(a, b, c) {
  console.log(a + b + c);
}

var 어레이 = [10, 20, 30];
더하기(...어레이);
```

그러면 출력했을 때 10, 20, 30을 더해준 결과가 잘 출력됩니다.

spread 연산자가 없던 시절엔 이런 식으로 작성했었습니다.

```js
function 더하기(a, b, c) {
  console.log(a + b + c);
}

var 어레이 = [10, 20, 30];
더하기(...어레이); //요즘방식
더하기.apply(undefined, 어레이); //옛날방식
```

apply라는 이상한 함수를 뒤에 붙여서 실행을 했었는데 이게 뭔지 자세히 알아보도록 합시다.  
나중에 객체지향 문법같은거 배우실 때 가끔 등장하는 함수들이니까요.

## apply, call 함수가 뭔지 알아보자

일단 예시를 들기 위해 오브젝트를 두개 만들어봅시다.

```js
var person = {
  인사: function () {
    console.log(this.name + "안녕");
  },
};

var person2 = {
  name: "손흥민",
};
```

person이라는 오브젝트에는 인사라는 함수를 만들어 넣었고  
person2는 보잘것없이 그냥 name : '손흥민' 이라는 자료만 넣었습니다.  
그런데 person에 만들어놓은 멋진 person.인사()라는 함수를 person2에서도 쓰고 싶습니다.  
그럼 어떻게 해야할까요?

person2에다가 직접 인사()라는 함수를 코딩해서 집어넣으면 되겠죠?  
근데 그게 불가능한 경우가 가끔 있습니다.  
그럴 때 apply를 쓰시면 됩니다.  
apply는 이 함수를 실행하는데.. 저기 오브젝트에다가 적용해서 실행해주세요~ 라는 뜻입니다.

그래서 한번 시도해봅시다.

```js
var person = {
  인사: function () {
    console.log(this.name + "안녕");
  },
};

var person2 = {
  name: "손흥민",
};

person.인사.apply(person2);
```

맨 마지막줄에 적은 코드가 뭔 의미냐면  
person.인사()라는 함수를 쓰는데 person2라는 오브젝트에 적용해서 실행해라
또는 person.인사()라는 함수를 쓰는데 person2라는 오브젝트에 있는 함수처럼 실행해라~ 라는 뜻입니다.

apply 함수의 사용법은

```js
실행할함수.apply(적용할곳);
```

이라고 보시면 됩니다.
이제 apply만 기억해주시면 여러가지 유용한 함수들을 내가 원하는 곳에 붙여서 쉽게 실행가능합니다.  
근데 이거랑 아주 똑같은 기능을 하는 함수가 하나 더 있습니다.

```js
var person = {
  인사: function () {
    console.log(this.name + "안녕");
  },
};

var person2 = {
  name: "손흥민",
};

person.인사.apply(person2);
person.인사.call(person2);
```

apply와 call은 실행 결과도 똑같고 사용법도 똑같습니다.  
하지만 차이점이 하나 있는데, 내가 person.인사()에 파라미터를 넣어서 실행하고 싶은 경우에는

```js
person.인사.apply(person2, 파라미터);
person.인사.call(person2, 파라미터);
```

이렇게 실행하셔야하는데  
이 때 apply는 파라미터를 `[array]`로 한꺼번에 집어넣을 수 있고
call은 그냥 1,2,3 이렇게 일반 함수처럼 만 집어넣을 수 있습니다.

```js
var person = {
  인사: function () {
    console.log(this.name + "안녕");
  },
};

var person2 = {
  name: "손흥민",
};

person.인사.apply(person2, [1, 2, 3]);
person.인사.call(person2, 1, 2, 3);
```

파라미터 집어넣는 방법만 좀 차이가 있지 아무튼 call, apply의 실행내용은 똑같습니다.
apply함수는 저렇게 어레이 내의 데이터를 파라미터로 한꺼번에 집어넣을 수 있다는 유용한 기능을 제공하기 때문에  
옛날 고대의 개발자들이 파라미터가 많은 함수를 만들 때 자주 사용했습니다.

그럼 이제 아까 함수에 array 집어넣는 예제가 이해가 가기 시작합니다.

```js
function 더하기(a, b, c) {
  console.log(a + b + c);
}

var 어레이 = [10, 20, 30];
더하기(...어레이); //요즘방식 넣기
더하기.apply(undefined, 어레이); //옛날방식 넣기
```

더하기.apply(undefined, 어레이)
무슨 뜻이냐면
더하기() 함수를 실행하는데 undefined에 적용해서 실행해주시고요 파라미터로 어레이를 집어넣어주세요~ 라는 뜻입니다.
이러면 편법같은 느낌이 들지만 array를 풀어헤쳐서 파라미터로 집어넣으실 수 있습니다.

# 함수 업그레이드하기 (default parameter/arguments)

함수를 만들 때 파라미터값을 실수로 안적었을 경우  
파라미터에 기본값(default 값)을 줄 수 있습니다.  
이렇게 사용하시면 됩니다.

```js
function 더하기(a, b = 10) {
  console.log(a + b);
}

더하기(1);
```

위 코드를 실행하면 11이 뜹니다.  
지금 더하기() 함수는 파라미터를 두개 입력할 수 있습니다.  
하지만 1이라는 파라미터 하나밖에 쓰지 않았습니다.  
그럴 때 저렇게 b = 10 선언해뒀던 default 파라미터값인 10이 b에 할당되게 됩니다.  
그래서 콘솔창에 a + b가 11이 출력되게 되는 것입니다.

default 파라미터를 주고 싶으면 저렇게 파라미터 선언하실 때 등호로 입력해주시면 됩니다.  
그럼 파라미터가 정의되지 않았을 때 등호 오른쪽 값이 발동됩니다.  
default 파라미터로 별게 다 들어갈 수 있습니다.

```js
function 더하기(a, b = 2 * 5) {
  console.log(a + b);
}

더하기(1);
```

수학 연산자도 사용가능합니다. b 자리에 파라미터가 없으면 2 \* 5라는 값을 할당해줍니다.

```js
function 더하기(a, b = 2 * a) {
  console.log(a + b);
}

더하기(3);
```

심지어 default 파라미터엔 함수입력도 가능합니다.

```js
function 임시함수() {
  return 10;
}

function 더하기(a, b = 임시함수()) {
  console.log(a + b);
}

더하기(3);
```

위 코드는 실행하면 13이 출력됩니다.  
b자리에 파라미터가 들어오지 않으면 임시함수()를 실행한 값을 b 파라미터에 할당해줍니다.  
임시함수()를 실행하면 그 자리에 10이 남습니다.  
(return 10이 그 뜻입니다)  
그래서 console.log(3 + 10)을 실행해줍니다.

## 함수의 arguments

함수의 모든 파라미터들을 전부 한꺼번에 싸잡아서 다루고 싶은 경우가 있습니다.  
그럴 땐 arguments라는 키워드를 활용하시면 됩니다.  
함수 안에서 쓸 수 있는 미리 정의된 키워드 혹은 변수인데  
한번 써보도록 합시다.

```js
function 함수(a, b, c) {
  console.log(arguments);
}

함수(2, 3, 4);
```

그러면 콘솔창에 `[2,3,4]`를 담은 array 비슷한 자료가 출력됩니다.  
arguments는 즉, 모든 입력된 파라미터를 [ ] 안에 싸매주는 고마운 키워드였던 것이었습니다.  
이제 여러분이 파라미터들을 한꺼번에 다루고 싶을 때 자주 활용해주시면 됩니다.  
예를 들면 이런 경우가 있겠군요.

콘솔창에 모든 파라미터를 하나씩 출력해주고 싶은 경우

```js
function 함수(a, b, c) {
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments[2]);
}

함수(2, 3, 4);
```

그런데 조금 더 확장성있게 반복문을 쓴다면

```js
function 함수(a, b, c) {
  for (var i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }
}

함수(2, 3, 4);
```

이러면 되겠군요.  
약간 편리하게 파라미터들을 다룰 수 있는 문법이었습니다.  
하지만 ES6문법 부터는 파라미터를 더 쉽게 다룰 수 있는 rest 파라미터라는 문법이 등장합니다.

# Rest parameter

함수를 만들 때 ...이라는 기호를 파라미터 왼쪽에 추가가능합니다.

```js
function 함수2(...파라미터들) {
  console.log(파라미터들);
}

함수2(1, 2, 3, 4, 5, 6, 7);
```

위 코드를 실행해보면 파라미터들이라는 변수를 출력해줍니다.  
파라미터들이라는 변수는 모든 파라미터를 [] array 안에 담고 있습니다.  
이게 바로 ES6 환경에서 쓸 수 있는 rest 파라미터입니다.  
원하는 파라미터 왼쪽에 ... 기호를 붙여주시면  
"이 자리에 오는 모든 파라미터를 [] 중괄호로 감싸준 파라미터" 라는 뜻입니다.

그래서 출력해보면 저렇게 `[1,2,3,4,5,6,7]`이 나오는 것이고요.  
그 자리에 입력한 모든 파라미터(1,2,3,4,5,6,7)를 중괄호에 감싸주는게 rest 파라미터입니다.

`...`을 다른 자리에 사용한다면

그 자리에 있는 파라미터를 [] 안에 감싸준다고 했으면  
다른 자리에 쓰면 어떻게 될까요?

```js
function 함수2(a, b, ...파라미터들) {
  console.log(파라미터들);
}

함수2(1, 2, 3, 4, 5, 6, 7);
```

위 코드를 실행해보면 `[3,4,5,6,7]`이 출력됩니다.  
첫 두개의 파라미터는 a, b로 쓰는데  
a,b 그 뒤에 나오는 모든 파라미터는 중괄호에 감싸서 파라미터들이라는 array가 됩니다.  
파라미터 종류가 많을 경우 arguments 문법보다 다루기 쉽고 간단해서 자주 사용합니다.

### 쓰기 전 주의사항

rest(나머지) 파라미터라는 뜻대로 나머지 부분에만 사용가능합니다.  
그니까 항상 파라미터가 여러개면 rest는 항상 마지막 파라미터로 넣으셔야합니다.

```js
function 함수2(a, ...파라미터들, b){
  console.log(파라미터들)
}
```

이렇게 사용하시면 에러난다는 소리입니다.

```js
function 함수2(a, ...파라미터들, ...파라미터들2){
  console.log(파라미터들)
}
```

이것도 안됩니다. 2개 이상 사용할 수 없습니다.

### 간단한 연습문제

모든 파라미터를 전부 하나씩 콘솔창에 출력해주는 함수를 만들고 싶습니다.

어떻게 해야할까요?

```js
function 함수(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

함수(1, 2, 3);
```

근데 파라미터를 4개 5개 오바해서 입력한 경우엔 제대로 실행이 되지 않는 멍청한 함수가 완성되었을 뿐입니다.  
파라미터 갯수 제한없이 똑같은 기능을 실행해주는 함수를 만들려면 어떻게 해야할까요?

```js
function 함수(...rest){
  console.log(rest[0]);
  console.log(rest[1]);
  console.log(rest[2]);
  (...이하 쭉쭉쭉)
}

함수(1,2,3);
```

이렇게 하면 되는거 아닙니까. 근데 파라미터가 몇개 들어갈지 모르기 때문에

console.log()부분을 반복문을 이용하면 만들 수 있습니다.

```js
function 함수(...rest) {
  for (var i = 0; i < rest.length; i++) {
    console.log(rest[i]);
  }
}

함수(1, 2, 3, 4, 5, 6, 7, 8);
```

rest라는게 모든 파라미터를 `[]` 안에 담아서 array처럼 만들어주는 고마운 변수기 때문에  
반복문을 저렇게 돌릴 수 있습니다.  
그럼 이제 함수에 파라미터를 몇개를 넣든 간에 콘솔창에 계속 출력을 해줄 수 있습니다.

영단어 rest가 뜻이 쉬다가 아니라 여분, 나머지 이런 뜻이잖아요.  
그러니 나머지 파라미터라고 외우시면 그나마 머릿속에 기억이 잘 될 것 같습니다.  
