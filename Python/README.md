# Python

# 파이썬으로 파일 read / write 하는 법

## 파일 쓰는 법

```py
파일 = open('a.txt', 'w')
파일.write('hello')
파일.close()
```

- a.txt라는 파일이 없으면 하나 만듭니다.
- 이미 있으면 내용을 덮어쓰기를 합니다.

## 파일 읽는 법

```py
파일 = open('a.txt', 'r')
print( 파일.read() )
파일.close()
```

## 파일에 내용 추가하는 법

```py
파일 = open('a.txt', 'a')
파일.write('hello')
파일.close()
```

이렇게 a라는 모드로 오픈하고 글쓰고 닫고 하시면 됩니다.

append라는 모드입니다. 내용을 덮어쓰기하는게 아니라 기존 내용에 hello라는 글자를 추가만 해줍니다.

# for 반복문

```py
for i in range(몇번반복할건지) :
  반복해줄코드
```

그러면 range()안에 넣은 숫자 갯수만큼 indent들어간 코드를 여러번 복사 (반복) 해줍니다.

이제 손수 복붙할 필요가 없어집니다.

그리고 i 라는 부분은 변수하나 아무렇게나 작명하시면됩니다. 전 i가 좋아서 i라고 했을 뿐입니다.

이 변수의 용도는 조금 나중에 소개해드립니다.

```py
for i in range(10) :
  print('BMW 있어요 사셈')
```

for 반복문을 적용했습니다. 그럼 열번정도 저 indent 들어간 코드를 복붙해줍니다.

i 라는 변수는 코드가 복붙될 때 마다 0,1,2 ... 이렇게 1씩 증가하는 숫자입니다.

진짜 확인하고 싶으면 i라는 변수를 print로 출력해보십시오.

## 반복문은 이럴 때도 씁니다

자료를 하나씩 출력하거나 하나씩 조작하고 싶을 때도 씁니다.

예를 들면 이런 데이터가 있다고 칩시다.

```py
중고차들 = ['K5', 'BMW', 'spark']
```

이 안에 있는 모든 데이터들을 하나씩 print 하고 싶으면 어떻게 코드를 짜야합니까.

대충 이런게 아닐까요.

```py
중고차들 = ['K5', 'BMW', 'Tico']
print(중고차들[0])
print(중고차들[1])
print(중고차들[2])
```

이러면 하나씩 다 출력해줄 수 있습니다. 끝입니다.

근데 이걸 똑같이 반복문으로 만들 수도 있습니다.

```py
중고차들 = ['K5', 'BMW', 'Tico']
for i in 중고차들:
print(i)
```

이러면 아까처럼 모든 데이터를 출력할 수 있습니다. 약간 코드가 더 줄었죠? 그래서 씁니다.

해설을하자면

1.  리스트자료형을 집어넣으면 리스트 갯수만큼 반복문이 실행됩니다. (3번반복되겠죠?)

2.  리스트 자료를 집어넣었을 땐 i라는 변수는 반복문이 실행될 때마다 리스트 안에있던 하나하나의 자료를 뜻합니다.

(그래서 i는 반복문이 실행될 때 차례로 K5, BMW, spark가 됩니다.)

이런 특징 때문에 range() 말고 리스트로 for 반복문을 돌리시면

그 리스트 안에 있던 자료를 쉽게 꺼내쓸 수 있게 됩니다. 자료꺼낼 때 쌩코딩안해도되고 편리해서 씁니다.

자료를 전부 조작하기도 쉬워집니다.

이번엔 그 K5, BMW 이런 글자 뒤에 "사세요~" 라는 단어를 붙여서 출력해주고 싶은겁니다.

코드를 어떻게 짜면 될까요 ㄷㄷ

```py
중고차들 = ['K5', 'BMW', 'spark']
for i in 중고차들:
print(i + '사세요!!!!!!!')
```

이러면 리스트 안에 있던 K5, BMW 이런 단어들 뒤에 "사세요!!!!!"를 붙여서 출력도 가능합니다.

이런 식으로 리스트 안에 있던 자료를 한꺼번에 조작하는 것도 쉬워지는 것입니다.

## 추가로 알아야할 것들

- 리스트 말고 딕셔너리 자료도 for 반복문에 입력가능합니다.

- range()를 쓰실 때 약간 더 명시적으로 쓸 수 있습니다. 숫자 두개도 입력 가능합니다.

range(0,10) 이렇게 쓰면 0부터 10이 되기 전까지 indent들어간 코드를 복붙해주세요~ (10번 복붙됨)

range(1,6) 이렇게 쓰면 1부터 6이 되기 전까지 indent 들어간 코드를 복붙해주세요~ (5번 복붙됨)

이런 뜻입니다.

- range를 저렇게 쓰실 경우 i의 값도 살짝 달라집니다.

range(0,10) 이렇게 쓰면 i는 복붙될 때 마다 1,2,3,4,5,6,7,8,9가 됩니다.

range(1,6) 이렇게 쓰면 i는 복붙될 때 마다 1,2,3,4,5가 됩니다.

(실은 range()함수는 리스트 만들어주는 함수라 그렇습니다. range(2,7) 이러면 `[2,3,4,5,6]` 이런 리스트가 그 자리에 남습니다. 이걸 알면 왜 i가 저렇게 변하는지도 이해가 되겠죠?)

# 함수문법 def

## 함수의 용도 1. 긴코드 짧게 축약할 때 씁니다

함수는 꼭 써야되는 문법도 아니고

내 코드에 멋좀 내기 위해 쓰는 것도 아닙니다.

자주쓰이는 긴코드가 있다면 그걸 짧은 한 단어로 축약하고 싶을 때 쓰시면 됩니다.

```py
print('안녕하세요 중고차신뢰딜러 차은우입니다')
print('현재 딜러할인 최대 적용중이라 쪽지로 문의주십쇼')
```

이런 긴 코드가 매우 자주 필요하다고 생각해봅시다.

그럼 그 때마다 이거 긴 코드 복붙하고 그래야하겠죠?

귀찮다면 함수문법을 쓰시면 이 긴 코드를 짧게 한 단어로 축약이 가능합니다.

```py
 def 인사하기():
    print('안녕하세요 중고차신뢰딜러 차은우입니다')
    print('현재 딜러할인 최대 적용중이라 쪽지로 문의주십쇼')

인사하기()
```

이렇게 하시면 되겠습니다.

이제 원하는 곳에서 인사하기() 이것만 쓰시면 긴 두줄의 코드가 출력됩니다.

앞으로 훨씬 코드가 간결해지겠군요.

## 함수의 용도 2. 마법의 모자 만들 때도 씁니다

여러분이 고등학교를 나왔다면 파이썬 함수는 수학의 함수와 똑같다라고 설명하면 바로 알아듣습니다.

"수학에선 f(x) = 2 + x 인 경우 f(2) 그리고 f(4) 이런걸 할 수 있지않냐 파이썬도 똑같습니다 끗"

여기까지 설명하면 함수 설명 끝인데

하지만 고등학교 기억이 없을 수 있으니 초등학교레벨로 설명해드리겠습니다.

2를 집어넣으면 4가 나오고

4를 집어넣으면 6이 나오고

이렇게 +2를 해주는 기계가 가끔 필요합니다.

가끔은 \* 2 해주는 기계도 가끔 필요하고요.

그런 마법의 모자가 필요하면 함수를 만들어쓰시면 됩니다.

파이썬 함수도 그런 magic hat 역할을 해줄 수 있습니다.

마법의 모자는 어떻게 만드냐면

```py
def 함수이름(인풋) :
    인풋으로 뭐할지 여기에 작성
```

이렇게 코드짜시면 됩니다. 그럼 마법모자 완성입니다.

예를 들면 뭔가 숫자를 집어넣으면 2를 더해주는 모자를 만들고 싶습니다.

그건 이렇게 만드시면 됩니다.

```py
def 모자(숫자) :
    print(숫자 + 2)
```

끝입니다.

그럼 이제 함수를 사용하실 때 함수소괄호안에 뭔가를 집어넣을 수 있는데

```py
def 모자(숫자) :
    print(숫자 + 2)

모자(4)
모자(6)
```

이렇게요.

이게 뭔뜻이냐면 모자()라는 함수를 쓰는데 숫자란에 4를 집어넣어서 실행해주세요~

모자()라는 함수를 쓰는데 숫자란에 6을 집어넣어서 실행해주세요~

라는 뜻입니다.

그럼 실행해보면 각각 6과 8이라는 결과가 뜰겁니다.

이게 아까말한 기계만드는 법입니다.

4를 집어넣으면 6 나오고 6 집어넣으면 8 나오죠?

그럼 집어넣은 숫자를 \* 2 해주는 함수는 어떻게 만들까요?

알아서 해보시면 되겠습니다.

(참고1) 함수안에 숫자만 넣는게 아니라 모든 자료형 다 넣을 수 있습니다.

(참고2) 집어넣는 숫자를 늘리고 싶으면 함수만들 때 def 함수(숫자1, 문자2) : 이렇게 콤마로 구분해서 여러가지 적으면 됩니다. 그리고 자유작명입니다. 그리고 집어넣는 숫자같은걸 전문개발용어로 파라미터라고 합니다.

(참고3) 함수는 위에서 만들어놔야 밑에서 함수() 이렇게 쓸 수 있습니다.

# 웹 크롤러

수집할 사이트 : https://finance.naver.com/item/sise.nhn?code=005930

평소에 웹에서 데이터수집 하는 업무를 자주 한다면 웹크롤러로 자동화 해놓으십시오.

데이터를 활용하는 IT 서비스를 창업하고 싶다면 웹크롤러를 사용하십시오.

데이터 분석 이전 분석할 데이터는 어디서 구할겁니까. 당연히 웹 크롤러를 사용합니다.

웹크롤러는 웹사이트에서 데이터를 가져와서 자동으로 정리/저장해주는 프로그램을 말합니다.

크롤러 만드는 법은 쉽습니다.

1. 파이썬으로 원하는 웹페이지 접속해서 그 페이지에 있는 HTML 그대로 전부 다운받음

2. 원하는 글자있는 부분만 딱 찝어냅니다.

3. 그걸 저장하든 뭐하든 합니다.

끝입니다.

반복문으로 1~3번 코드를 복붙하면 단시간에 백만개 페이지 수집하는 프로그램도 만들 수 있겠군요.

## CSS 셀렉터 참고용

CSS 셀렉터를 알고계시면 soup.select() 함수를 이용해서 원하는 데이터를 더욱 엄격하게 자세하게 찾을 수 있습니다.

```py
soup.select('.class명')
soup.select('#id명')
soup.select('태그명') (HTML 태그명은 아무것도 안붙임)
soup.select('.class명1 .class명2') (띄어쓰기는 '~내부의' 라는 뜻)
```

## 이미지 URL을 알고있을 때 파일로 저장하는 법

```py
import urllib.request #import 모여있는 맨위에다가 작성

urllib.request.urlretrieve(이미지URL, '파일명')
```

이 코드 한줄이면 됩니다. 끝!

이미지 URL 란에는 여러분이 찾아온 이미지 URL 진짜 담으시면 되고

'파일명' 부분에는 '어쩌구.jpg' 이런 식으로 파일명 맘대로 작성해주시면 됩니다.

실행하면 파이썬 파일이랑 나란한 곳에 어쩌구.jpg가 저장됩니다.

## 함수에 파라미터 구멍을 뚫을 때 잘보고 해야합니다.

구멍뚫기 문법을 사용하면 함수를 업그레이드할 수 있습니다.

이전 문법예제처럼 3을 집어넣으면 1+3을 연산해주고 4를 집어넣으면 1+4를 연산해주는 다양한 기능을 할 수 있는 함수를 만들려면

함수에 구멍만 뚫어주시면 됩니다.

대충 뚫으시면 된다고 했는데 실은 아무데나 막 집어넣으시면 안됩니다.

구멍이라는 글자는 일종의 변수 이기 때문에 변수처럼 생각해서 잘 넣으셔야합니다.

- 다른 변수이름 중간에 집어넣을 수 없습니다.

- '문자자료형' 중간에 구멍을 뚫고 싶으면 특수한 방법이 필요합니다.

문자자료형 중간에 구멍을 뚫고 싶어서 이렇게 했는데

```py
def 현재가(구멍):
  데이터 = requests.get('https://finance.naver.com/item/sise.nhn?code=구멍')
```

이렇게 대충 문자자료 중간에 '구멍'이라고 집어넣으면 안된다는 소리입니다.

저렇게 집어넣으면 "구멍에 들어온 값을 여기 집어넣어주세요~"라는 뜻이 아니라

구멍이라는 일반 문자로 변해버립니다

그래서 문자 중간에 변수를 넣을 땐 변수가 문자로 바뀌지 않도록 보존해서 집어넣으셔야 하는데

formatting 문법을 이용하시면 안전하게 문자중간에 변수를 집어넣을 수 있습니다.

파이썬에서 문자중간에 변수를 넣고 싶으면

```py
f'문자 {변수} 문자'
```

1. 이렇게 문자중간에 {} 기호로 변수이름을 집어넣고

2. f를 맨앞에 추가합니다.

이게 formatting 문법 끝입니다. (옛날 책 보시면 % 어쩌구 이런거 썼는데 요즘은 이렇게 합니다)

```py
def 현재가(구멍):
  데이터 = requests.get(f'https://finance.naver.com/item/sise.nhn?code={구멍}')
```

결론은 문자중간에 구멍을 뚫고 싶으면 이렇게 하라는 소리입니다.

길었던 코드 함수로 축약하기 프로젝트 끝!

그럼 이제 함수사용할 때 구멍자리에 원하는 종목코드를 넣으면 그 종목의 현재가격 등을 알아서 출력해줍니다.

예를 들면 현재가('005930') 이런 코드를 작성하면 삼성전자 현재가를 출력해주겠군요.

함수를 쓰고난 자리에 뭔가 퉤 뱉고 싶습니다

```py
def 예시함수():
  return '어쩌구'
```

이렇게 쓰시면 예시함수()를 실행하고나서 그 자리에 '어쩌구'라는 데이터를 뾰로롱 남겨줍니다.

퉤~ 뱉는다고 기억해주셔도 됩니다.

그럼 우리가 만들었던 크롤러 함수를 이렇게 업그레이드하면 어떻게 될까요.

```py
def 현재가(구멍):
  데이터 = requests.get(f'https://finance.naver.com/item/sise.nhn?code={구멍}')
  soup = BeautifulSoup(데이터.content, 'html.parser')
  return soup.find_all('strong', id="_nowVal")[0].text
```

현재가() 함수를 실행하고 나면 그 자리에 `soup.find_all('strong', id="_nowVal")[0].text` 이런걸 퉤 뱉어줍니다.

그리고 그것은 현재 가격입니다.

예를 들면 현재가('005930') 이런 코드를 작성하면 그 자리에 삼성전자 현재가격이 뾰로롱 남습니다.

return 덕분입니다.

그럼 이제

```py
price = 현재가('005930')
f.write(price)
```

변수에 저장하든지

파일에 작성하든지

리스트에 append() 로 추가 해보던지 맘대로 다루기 쪼금 더 편리해집니다.

그래서 return을 사용합니다.

def, return, for 이런거 문법을 외우는게 중요한게 아니라 문법을 대체 언제 써야 하는지 아셔야 스스로 프로그래밍 잘하는 사람이 됩니다.

언제쓰는지 모르면 "함수 여기서 쓰는거맞아요? 반복문 이거 꼭 써야해요?" 이런 질문을 평생하게 됩니다.

# JSON데이터 다루기

JSON 파일을 가져오는 법은 똑같습니다. 그냥 Headers 탭 가서 어떤 URL로 어떤 요청을 하면 가져올 수 있는지 살펴보시고

파이썬으로 그대로 따라하시면 됩니다.

```py
import requests

data = requests.get('저거URL')
print(data)
```

그래서 URL로 GET 요청을 하고 싶으면 파이썬으로 이렇게 코드짜면 되는 것일 뿐입니다.

그럼 저 데이터 파일이 도착합니다.

근데 출력해보니 { "어쩌구" : "저쩌구" } 이런 데이터가 가득 담겨있습니다.

딕셔너리같이 생겼죠? 근데 실은 딕셔너리가 아니라 JSON입니다.

딕셔너리는 { '어쩌구' : '저쩌구' }

JSON은 { "어쩌구" : "저쩌구" }

이렇게 생겼습니다.

JSON은 딕셔너리처럼 생겼지만 딕셔너리처럼 데이터를 쉽게 뽑거나 그럴 수 없어서

JSON -> 딕셔너리로 바꿔주셔야 인생이 편해집니다.

그것은 큰 따옴표를 님들이 직접 작은 따옴표로 손수 바꾸시거나

```py
import json
바꾼거 = json.loads(JSON데이터~~)
print(바꾼거)
```

이런 함수를 쓰시면 됩니다.

json.loads( ) 안에 JSON 데이터를 넣으시면 깔끔한 딕셔너리가 그 자리에 남습니다.

그걸 변수에 저장해서 쓰든 뭐하든 하시면 되겠습니다.

## 중첩 데이터 다루기

개발하다보면 매우 중첩된 리스트, 중첩된 딕셔너리를 만나는 경우가 잦습니다.

```py
data = [
  { 'name' : 'john', 'age' : 20 }
]
```

위의 코드가 좋은 예인데 data라는 변수에는 리스트, 그리고 그 안에 딕셔너리가 저장되어있습니다.

(리스트나 딕셔너리 안에는 여러분이 상상하는 모든 자료형을 집어넣을 수 있어서 저런게 가능합니다.)

여기서 20 이라는 데이터를 뽑아 출력해보고 싶으면 print()문 안에 뭘 적어야할까요?

print(data[??]) 뭐 이런 식이 아닐까요. 근데 물음표 자리에 뭘 써넣어야하죠?

복잡한 자료에서 원하는걸 딱 뽑아내려면 이 자료가 무슨 괄호들 안에 들었는지 쭉 나열하시면 됩니다.

딱봐도 [] 안에 {} 안에 원하는 자료가 있죠?

그러면 data라는 변수에다가

1. 리스트에서자료뽑기
2. 딕셔너리에서자료뽑기

이걸 차례로 하시면 되는겁니다.

만약에 원하는 자료가 {} 안에 [] 안에 있으면

data에서

1. 딕셔너리에서자료뽑기
2. 리스트에서자료뽑기
   이걸 차례로 하시면 되는겁니다.

[] 이건 리스트고 {} 이건 무조건 딕셔너리입니다.

그럼 위의 예제에서 20이라는 숫자를 뽑고 싶으면 "리스트안에 딕셔너리안에 원하는 데이터"가 있으니까

```py
data = [
  { 'name' : 'john', 'age' : 20 }
]
print(data[0]['age'])
```

이렇게 적으면 뽑힙니다.

차례로

1. 리스트에서 자료뽑기
2. 딕셔너리에서 자료뽑기 한거 맞죠?

뽑길 원하는 자료가 무슨 괄호들이 감싸고 있는지 파악하시면

그 어떤 어려워보이는 중첩된 자료형도 쉽게 자료 뽑아쓸 수 있습니다.

저렇게 생긴걸 많이 만들어보시면 뽑는 것도 쉬운데

그런거 만들 일이 별로 없으니 뽑는 법을 위주로 알려드립니다.

## 복잡한 딕셔너리/리스트에서 데이터를 출력하고 싶으면

뽑고 싶은 데이터가 어떤 괄호안에 있는지를 조사하면 쉽게 뽑을 수 있습니다.

```py
딕셔너리 = {
  'success' : true,
  'data' : [
    {
      'DT' : 1610240400000,
      'Close' : '1504600'
    },
    {
      'DT' : 1610244400000,
      'Close' : '1521200'
    },
  ]
}
```

예를 들면 여기서 둘째 Close 가격인 1521200을 뽑고 싶다면 이 데이터는 어떤 괄호들 안에 들어있습니까.

{} 안에 [] 안에 {} 안에 들어있지않나요? 대충 축약하면 이렇게 생겼습니다. { [ {뽑을데이터} ] }

그럼 이제 딕셔너리에서 데이터를 뽑을 때

```py
print({딕셔너리}에서뽑고 [리스트]에서뽑고 {딕셔너리}에서뽑고)
```

이렇게 차례로 3번 뽑으시면 원하는걸 출력가능합니다.

```py
print(딕셔너리['data'][1]['Close'])
```

딕셔너리에서 데이터뽑을 땐 자료의 이름 key값 불러주시면 되고

리스트에서 데이터뽑을 땐 숫자로 인덱싱 해주시면 됩니다.

그래서 이렇게 썼더니 데이터가 뽑혔습니다.

이것만 그대로 받아적고 외우는게 아니라

Close 가격말고 다른 데이터를 뽑으려면 어떻게 코드를 짜야할지 연습해보시는걸 매우 추천드립니다.

여기서 안해보면 앞으로 평생 복잡한 자료형 무서워함

## 시간형식이 좀 이상합니다.

DT라는 정보에 1610240400000 이런게 들어있습니다.

실은 이게 프로그래밍할 때 가끔 쓰는 시간형식인데 일명 Epoch 타임이라고 합니다.

1970 1월 1일 부터 지금까지 몇초나 흘렀는지를 초단위로 알려주는 시간형식입니다.

(실은 원래 10자리인데 13자리의 경우 ms 단위로 표현한 것입니다)

왜 쓰냐면 그냥 시간 두개를 더하고 빼기 쉬워서 쓰는데 이걸 사람이 보는 시간형식으로 변환할 수 있습니다.

```py
import time
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(epoch시간형식))
```

1. 기본내장된 time 라이브러리를 가져오고

2. time.strftime 쓰시면 됩니다. 두개 파라미터를 입력가능한데 왼쪽엔 어떤 글자로 변환할지, 오른쪽엔 epoch 시간을 입력해줍니다. 10자리로요.

시간 자주 사용하니까 다음 시간엔 시간 다루는 법을 알아보도록 합시다.

# 자주쓰는 time과 formatting 문법

프로그래밍할 때 시간을 어디 적는 일이 많습니다.

시간을 기록할 때 우리 인간이 보는 년월일 이런걸 사용하면 더하고 빼기 살짝 불편해서

Epoch 아니면 Unix 라고 부르는 시간형식이 있습니다. 그걸 가끔 사용합니다.

1970년 1월1일 부터 지금까지 몇초나 흘렀는지를 알려주는 시간 형식입니다.

```py
import time
print(time.time())
```

이렇게 쓰시면 1610175600 이런 식으로 시간이 출력됩니다. 일명 Epoch Time 입니다.

```py
import time
시간 = time.ctime(1610175600)
print(시간)
```

Epoch 타임이 보기싫으시면 인간이 읽을 수 있는 시간형식으로 변환하실 수 있습니다.

```py
import time
시간 = time.localtime()
print(시간)
print(시간.tm_year)
print(시간.tm_mon)
print(시간.tm_mday)
```

아니면 애초에 이렇게 localtime() 쓰시면 뽑아쓰기 좋게 년월일, 시분초를 담아줍니다.

오늘의 날짜, 시간 일부만 따로 출력할 일이 있으면 저렇게 년월일 뽑아쓰십시오.

Epoch 타임을 localtime() 안에 집어넣으면 년월일 시분초로 바꿔줍니다.

```py
import time
시간 = time.localtime()
time.strftime('%Y년 %m월 %d일', 시간)
print(시간.tm_year)
print(시간.tm_mon)
print(시간.tm_mday)
```

시간형식을 조금 더 자유롭게 표기하고 싶으면 strftime() 함수를 가져다 쓰시면 됩니다.

이건 두개의 파라미터를 입력가능한데 첫째 파라미터엔 어떤 식으로 표현해줄지 포맷팅문법을,

둘째파라미터는 localtime() 형식의 시간 (일명 struct_time object라고함) 을 집어넣으시면 됩니다.

%Y 년

%m 월

%d 일

%H 시

%M 분

%S 초

를 사용하시면 됩니다.

## 문자열 포맷팅

그냥 문자중간중간에 변수/다른 문자를 넣을 때 쓰는 문법을 formatting 문법이라고 합니다.

```py
name = 'Kim'
print( '안녕하세요 (저거변수에있던이름여기넣고싶음)' )
```

저거 name이라는 변수에 있던 데이터를 글자중간에 집어넣고 싶으면 코드를 어떻게 짜면 되냐면

```py
name = 'Kim'
print( '안녕하세요 %s' %name )
```

`%s` 라고 사용하신 뒤에

글자 뒷편에 %변수명을 입력하시면 됩니다. 그럼 변수가 `%s` 있던 자리에 쏙 박힙니다.

그럼 안녕하세요 Kim이 출력됩니다.

## 요즘 formatting 문법은 (python 3.6 이상)

```py
name = 'Kim'
print( f'안녕하세요 {name}' )
```

문자 왼쪽에 f라는 키워드를 집어넣으신다면

중괄호를 아무데나 글자중간중간열어서 변수명을 집어넣을 수 있습니다.

그럼 안녕하세요 Kim이 출력됩니다.

```py
import datetime
시간 = datetime.datetime(2022, 10, 20)
print(시간)
```

아니면 정말 귀찮으시면 datetime 라이브러리를 이용하면 쉽게 시간형식으로 표기해줍니다.

또는 datetime.datetime.now() 라고 쓰시면 현재시간도 출력해줄 수 있습니다.

# 파이썬 멀티쓰레딩

URL들에 GET 요청을 하면 JSON 데이터가 오는데 이걸 간단하게 하나만 출력하는 크롤러를 만들어봅시다.

실은 저번시간에 JSON 어쩌구 다룰 때 만들어뒀던 크롤러 코드 그대로쓰시면 됩니다. 근데 함수로 싸매서 쓸겁니다.

```py
import requests
import json
import time

def 함수(구멍):
  data = requests.get(구멍)
  딕셔너리 = json.loads(data.content)
  return 딕셔너리['data'][0]['Close']
```

이제 앞으로 함수('URL어쩌구') 이렇게 사용하면 이 자리에 데이터가 뾰로롱 남습니다.

아주 멋진 크롤러입니다.

위에서 작성한 URL을 전부 수집하려면 코드 어떻게 짜야하죠?

함수에다가 0번째 URL, 1번째 URL ... 전부 한번씩 집어넣으면 끝이죠?

함수( url[0] )

함수( url[1] )

함수( url[2] )

... 이렇게 계속 하시면 됩니다. 반복문 필요하면 쓰면 되고요.

근데 문제는 처리 시간입니다.

URL 하나 수집하는데 0.1초걸린다고 가정하면 100만개 수집하려면 몇초인가요?

10만초 걸립니다. 27시간이네요 ㄷㄷ

해결책은 멀티프로세싱/멀티쓰레딩을 이용하시면 됩니다.

파이썬 실행창 프로세스를 여러개 띄우는 멀티프로세싱을 쓰시던가

여러분 PC에 내장된 CPU 쓰레드 여러개로 작업을 나눠서 시키든가 하시면 됩니다.

## 멀티쓰레딩/프로세싱 쉽게 하는 법

원래 class 문법 기반으로 Producer/Consumer 어쩌구를 만들어 쓰는 게 기본인데

그것보다 훨씬 쉽게 "컴퓨터야 그냥 니가 알아서 멀티쓰레딩 해와라"는 식의 방법이 하나가 있습니다.

multiprocessing.Pool.map 이라는 함수입니다. 써봅시다.

```py
from multiprocessing.dummy import Pool as ThreadPool

pool = ThreadPool(4)
pool.map(작업시킬함수, 작업시킬리스트)
pool.close()
pool.join()
```

4줄 컷입니다.

기본 내장라이브러리를 저렇게 import 해오시고 (멀티쓰레딩하는 법인데 멀티프로세싱을 하려면 .dummy를 제거합니다)

ThreadPool() 에다가 몇개의 프로세스/쓰레드로 동시에 작업을 시킬지 숫자로 적으시고

map 에다가는 저거 적으시면 됩니다. 끝!

그 다음에 마무리되면 close() join() 을 차례로 해주면 됩니다. (작업 고만시키고 작업한거 join 그니까 전부 가져오라는 뜻입니다.)

그럼 map()에서 리스트안에 있던 자료들을 전부 함수에 차례로 집어넣어주는데 그 집어넣은 결과를 리스트로 만들어줍니다.

근데 그냥 해주진 않고 멀티쓰레딩을 이용해서 분산처리를 지가 알아서 해준다는 겁니다.

```py
리스트 = [2,3,4,5,6]
```

이런 리스트가 있습니다. 이 안의 모든 자료에 1씩 더한 새로운 리스트를 만들고 싶으면 코드를 어떻게 짤까요?

가장 쉽고 직관적인건

- 리스트[0]에 1더해주셈 그걸 새로운 리스트에 추가

- 리스트[1]에 1더해주셈 그걸 새로운 리스트에 추가

..

이렇게 하드코딩하거나 반복문을 사용하는 겁니다.

이게 싫으면 기본 내장 함수인 map을 사용하십시오.

```py
map(함수넣으셈, 리스트넣으셈)
```

map 함수는 내가만든 함수와 리스트자료를 입력할 수 있습니다. (파라미터 두개입력가능)

그러면 리스트 안에 있던 모든 자료에 함수를 적용시켜줍니다.

그래서 모든 리스트자료에 1을 더한다는 아까의 기능을 만들고 싶으면

1. 뭔가 집어넣으면 1을 더해서 퉤 뱉어주는 함수 만들고

2. 그걸 리스트자료와 함께 map에 집어넣으면 됩니다.

그럼 그 함수를 리스트 안에 있던 모든 자료에 전부 적용해줍니다.

```py
리스트 = [2,3,4,5,6]
def 더해주셈(x):
  return x + 1

result = map(더해주셈, 리스트)
print(result)
```

그래서 방금 말한 1번과 2번을 개발해본겁니다.

그럼 아까와 똑같은 1더해주는 기능을 약간 더 쉽게 짤 수 있습니다.

어색하고 거부감이 드는 이유는 아직 안외웠기 때문입니다.

이것 역시 암기의 영역이니 map을 어떻게 쓰는지 빨간 글씨와 step 1, 2번을 외워두도록 합시다.

pool.map 함수도 똑같은데 멀티쓰레딩으로 처리해줍니다.

멀티쓰레딩 라이브러리에 있는 map 함수 사용법도 아까랑 똑같은데

다만 이 map 함수는 멀티쓰레딩식으로 분산처리를 지가 알아서 해준다는 소리입니다.

그니까 map 함수에 데이터 100만개 들어있는 리스트 자료를 넣으시면

데이터 100만개를 프로세스/쓰레드가 각각 몇개씩 나눠가진 다음 분산처리 해준다는 겁니다.

그럼 처리시간이 적게 걸리겠죠? 그래서 사용합니다.

그래서 코드를 이렇게 짰습니다.

```py
from multiprocessing.dummy import Pool as ThreadPool

def 함수(구멍):
  data = requests.get(구멍)
  딕셔너리 = json.loads(data.content)
  return 딕셔너리['data'][0]['Close']

pool = ThreadPool(4)
result = pool.map(함수, url)
pool.close()
pool.join()

print(result)
```

프로세스/쓰레드를 4개 쓴다고 써놔서 4분의1 시간이 걸린다고 예상할 수 있겠지만

그것은 이론상일 뿐이고

일단 이 예제는 그냥 실행할 때 보다 절반 이하의 시간으로 모든 URL 수집을 처리할 수 있습니다.

실전에서는

- 수집 필요한 모든 URL을 리스트[ ] 자료에 담아두신 다음

- URL을 입력하면 수집 결과를 퉤 뱉어주는 크롤러함수를 만들어두고

- 그거 두개를 동시에 멀티쓰레딩 map 함수에 집어넣으면 되겠네요.
