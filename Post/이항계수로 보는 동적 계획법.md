백준에서 이항계수를 풀다가 마주한 문제 중 일부는 재귀 호출을 이용하여 해결했으나, 다른 이항계수 문제에서는 재귀 호출만으로는 시간 초과 문제가 발생하는 경우가 있었습니다. 이에 대한 해결책으로 동적 계획법을 사용하는 것을 검색을 통해 알게 되었습니다. 

동적 계획법은 이론적으로 알고 있었지만 실제로 어떻게 적용하는지에 대한 이해가 부족했습니다. 그래서 이항계수 문제를 동적 계획법과 재귀 호출을 활용하여 풀어보면서, 두 접근 방식 간의 차이와 정의, 작동 방식에 대해 자세히 정리하고자 합니다.

## 1. 이항계수란?

이항계수는 조합론(Combinatorics)에서 중요한 개념으로, 주어진 집합에서 원하는 수의 원소를 선택하는 방법을 나타내는 수학적인 값입니다. 이항계수는 주로 $n \choose k$ 또는 $C(n, k)$로 표기되며, n개의 원소가 있는 집합에서 k개의 원소를 선택하는 방법의 수를 나타냅니다. 이항계수는 확률, 통계, 조합론, 이산수학 등 다양한 수학 분야에서 사용되며, 이항분포, 이항정리, 이항계수 공식 등과 연관된 다양한 응용이 있습니다. 예를 들어 과일 중에서 몇 개를 선택하거나 동전 던지기와 같은 확률 문제를 다룰 때 유용합니다. 

이항계수를 계산할 때 [파스칼의 삼각형(Pascal's Triangle)](https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%8A%A4%EC%B9%BC%EC%9D%98_%EC%82%BC%EA%B0%81%ED%98%95)이라고 불리는 특별한 삼각형을 활용할 수 있습니다. 파스칼의 삼각형은 이항계수를 직관적으로 시각화한 것으로, 각 숫자가 이항계수 값을 나타냅니다. 이 삼각형은 다양한 수학적 문제에서 유용하게 활용되며, 이항계수의 계산을 단순화하는 데 도움을 줍니다. 이러한 이유로 이항계수와 파스칼의 삼각형은 중요한 수학적 도구로 자리잡고 있습니다.

이항계수와 밀접하게 관련된 파스칼의 삼각형(Pascal's Triangle)은 이항계수를 직관적으로 시각화한 특별한 패턴입니다. 파스칼 삼각형을 설명한 이유는 이항계수를 파이썬 코드로 설명할 때 시각적으로 확인하는데에 효과적이어서 설명에 덧붙여 봤습니다

![스크린샷 2023-07-04 오후 3 48 20](https://github.com/Zamoca42/TIL/assets/96982072/0c977162-7dbe-4c11-a538-6fa5862e6cf2)

## 2. 재귀호출

재귀 호출(Recursion)은 함수가 자기 자신을 호출하는 프로그래밍 기법입니다. 이를 통해 복잡한 문제를 더 작은 부분 문제로 나누어 해결할 수 있습니다. 재귀 호출은 기본 사례(재귀 호출을 멈추는 조건)와 재귀 단계(자기 자신을 호출하여 문제를 더 작은 부분 문제로 분할)로 구성됩니다. 예를 들어, 팩토리얼 계산이나 피보나치 수열 계산과 같은 문제는 재귀 호출을 활용하여 해결할 수 있습니다.

```Python
def factorial(n):
    if n == 1:      # n이 1일 때
        return 1    # 1을 반환하고 재귀호출을 끝냄
    return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함
 
print(factorial(5)) # 결과: 120
```

재귀 호출은 분할 정복의 일부분으로 볼 수 있습니다. 분할 정복(Divide and Conquer)은 큰 문제를 작은 부분 문제로 나눈 다음, 부분 문제들을 해결하고 그 결과를 결합하여 전체 문제를 해결하는 전략입니다. 이러한 전략은 주로 재귀 호출을 사용하여 구현됩니다. 분할 정복은 주로 다음 세 단계로 진행됩니다.

- **분할 (Divide):** 큰 문제를 더 작은 부분 문제로 나눕니다.
- **정복 (Conquer):** 작은 부분 문제들을 재귀적으로 해결합니다.
- **결합 (Combine):** 부분 문제들의 해를 결합하여 전체 문제의 해를 얻습니다.

재귀 호출은 분할 정복의 "정복" 단계에서 주로 사용됩니다. 큰 문제를 해결하기 위해 작은 부분 문제를 재귀적으로 해결하는 데에 재귀 호출을 활용합니다. 이항계수를 재귀 호출로 풀어볼 수 있습니다.

```Python
def bino_coef(n, k):
	if k == 0 or n == k:
		return 1
	return bino_coef(n-1, k) + bino_coef(n-1, k-1)

print(bino_coef(4, 2)) # 결과: 6
```

재귀 호출의 시간복잡도는 $O({n \choose k})$로 순수한 재귀 호출로 이항계수를 계산하면 지수적으로 많은 중복 계산이 발생할 수 있습니다. 이는 큰 n과 k에 대해서 매우 비효율적인 계산을 의미합니다.

![스크린샷 2023-07-04 오후 3 39 13](https://github.com/Zamoca42/TIL/assets/96982072/c5fb0154-ddaa-4abd-9388-3e38217513fd)

이항계수를 순수한 재귀 호출만을 사용하여 계산하는 것은 효율적이지 않으며, 큰 입력에 대해서는 문제가 발생할 수 있습니다. 이러한 단점을 극복하기 위해 동적 계획법의 메모이제이션(Memo)을 활용하여 중복 계산을 피하고 시간과 공간 효율성을 개선하는 것이 일반적인 접근 방식입니다.
## 3. 동적 계획법

동적 계획법(Dynamic Programming)은 큰 문제를 작은 부분 문제로 나누고, 작은 부분 문제의 해결 결과를 저장하여 중복 계산을 피하며 효율적으로 문제를 해결하는 알고리즘 설계 기법입니다. 주로 최적화 문제나 최장 경로 문제 등 다양한 문제에 적용됩니다. 동적 계획법은 분할 정복과 비슷해보이지만 동적 계획법의 핵심 아이디어는 **저장과 재활용**입니다. 이 저장과 재활용을 메모이제이션(Memoization)이라고도 부릅니다.

이항계수 문제를 동적 계획법을 활용하여 해결할 때, 문제를 작은 부분 문제로 나누고 이를 효율적으로 해결합니다. 먼저 문제를 해결할 수 있는 **점화식**을 구하고, 가장 작은 입력사례로부터 차례로 리스트에 저장해서 **상향식 방법으로 문제를 해결할 수 있습니다.** 

동적계획법을 통해서 이항계수를 나타내는 방법은 다음과 같습니다.

```python
def bin2(n, k):
	B = [[0] * (k + 1) for _ in range(n + 1)]
	
	for i in range(n + 1):
		for j in range(min(i, k) + 1):
			if (j == 0 or j == i):
				B[i][j] = 1
			else:
				B[i][j] = B[i - 1][j - 1] + B[i - 1][j]
	return B[n][k]

for n in range(10):
	for k in range(n + 1):
		print(bin2(n, k), end = " ")
	print()
```

출력:
```
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
```

위의 코드에서는 2차원 리스트를 사용하여 이항계수를 계산했지만, 1차원 리스트로도 구현이 가능하며 파스칼 삼각형의 대칭성을 이용하여 효율적으로 계산할 수 있습니다. 이를 통해 중복 계산을 피하고, 시간 복잡도를 효율적으로 $O(nk)$로 줄일 수 있습니다.

![스크린샷 2023-07-04 오후 5 19 02](https://github.com/Zamoca42/TIL/assets/96982072/0d9a9365-ddc9-42cd-9f5e-6a98064d4790)

```python
def bin3 (n, k):
	if (k > n // 2):
		k = n - k
	B = [0] * (k + 1)
	B[0] = 1
	for i in range(1, n + 1):
		j = min(i, k)
		while (j > 0):
			B[j] = B[j] + B[j - 1]
			j -= 1
	return B[k]

for n in range(10):
	for k in range(n + 1):
		print(bin3(n, k), end = " ")
	print()

print(bin3(9, 5))
```

출력:
```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1 
1 9 36 84 126 126 84 36 9 1 
126
```
## 4. 백준 2748 - 피보나치 수

[백준 2748번 피보나치 수 2](https://www.acmicpc.net/problem/2748)문제에서 피보나치 수를 구할 때 동적계획법을 활용 해보겠습니다.

피보나치 수는 0과 1로 시작합니다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 됩니다.

이를 점화식으로 나타내면 $F_n = F_{n-1} + F_{n-2} \ \mbox{(n ≥ 2)}$ 이고 $n = 17$ 일 때 까지 피보나치 수를 써보면 다음과 같습니다.

```
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
```

만약 피보나치 수를 재귀 호출로 작성했다면

```python
def fibonacci_recursive(n): 
	if n <= 0: 
		return 0 
	elif n == 1: 
		return 1 
	else: 
		return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
```

n번째 피보나치 수를 계산하는 데 $O(2^n)$의 시간이 소요됩니다.
이를 동적계획법으로 나타낸다면 시간 복잡도는 $O(n)$입니다.

```Python
n = int(input())
array = [1] * (n + 1)
array[0] = 0

for i in range(2, n + 1):
  array[i] = array[i - 1] + array[i - 2]

print(array[n])
```

동적 계획법을 사용하여 피보나치 수열을 계산할 경우, 중복 계산을 피하고 결과를 저장하기 때문에 시간 복잡도가 훨씬 효율적입니다.

## 5. 마무리

이항계수 문제를 해결하는 방법으로 분할정복법과 동적계획법 두 가지 접근 방식에 대해 알아봤습니다. 
위의 내용을 요약하면 다음과 같습니다.

- 문제를 작은 사례로 분할하여 해결한다는 점에서 동일
	- 분할 정복: 재귀 호출을 통해 분할하여 정복 (Top - Down)
	- 동적 계획: 메모이제이션을 통해 상향으로 정복 (Bottom - Up)

- 동적계획법은 분할정복법보다 훨씬 효율적
	- 분할정복법의 시간복잡도 $O({n \choose k})$
	- 동적계획법의 시간복잡도 $O(nk)$

긴 글 읽어주셔서 감사합니다.